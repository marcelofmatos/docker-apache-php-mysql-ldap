name: üöÄ Deploy to Docker Swarm

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      tag:
        description: 'Docker image tag to deploy'
        required: true
        default: 'latest'
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: üì¶ Checkout repository
        uses: actions/checkout@v4

      - name: üè∑Ô∏è Set deployment variables
        id: vars
        run: |
          if [[ "${{ github.event_name }}" == "release" ]]; then
            TAG=${GITHUB_REF#refs/tags/}
            ENV="production"
          else
            TAG="${{ github.event.inputs.tag }}"
            ENV="${{ github.event.inputs.environment }}"
          fi
          echo "IMAGE_TAG=${TAG}" >> $GITHUB_OUTPUT
          echo "ENVIRONMENT=${ENV}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_TIME=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT

      - name: üîê Setup SSH
        run: |
          # Create SSH directory and key file
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Disable strict host checking for deployment
          cat >> ~/.ssh/config << EOF
          Host *
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
          EOF

      - name: üìù Create deployment files
        run: |
          # Create environment file
          cat > .env.deploy << EOF
          PROJECT_NAME=${{ vars.PROJECT_NAME }}
          IMAGE_TAG=${{ steps.vars.outputs.IMAGE_TAG }}
          DOMAIN=${{ vars.DOMAIN }}
          REPLICAS=${{ secrets.REPLICAS || '2' }}
          VITE_SUPABASE_URL=${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_PUBLISHABLE_KEY=${{ secrets.VITE_SUPABASE_PUBLISHABLE_KEY }}
          VITE_SUPABASE_PROJECT_ID=${{ secrets.VITE_SUPABASE_PROJECT_ID }}
          EOF
          
          # Create deployment script
          cat > deploy.sh << 'DEPLOY_EOF'
          #!/bin/bash
          set -e
          
          cd ~/deployments/$PROJECT_NAME
          
          echo "üöÄ Starting deployment..."
          echo "Project: $PROJECT_NAME"
          echo "Image Tag: $IMAGE_TAG"
          echo "Domain: $DOMAIN"
          
          # Debug: Check files in directory
          echo "üîç Files in deployment directory:"
          ls -la
          
          # Load environment variables
          export $(cat .env | xargs)
          
          # Pull the latest image
          echo "üì• Pulling Docker image..."
          docker pull ghcr.io/abstraktagencia/fishboard:$IMAGE_TAG
          
          # Deploy/update the stack
          echo "üì¶ Deploying stack..."
          if [ -f "docker-compose.yml" ]; then
            echo "Using docker-compose.yml"
            COMPOSE_FILE="docker-compose.yml"
          else
            echo "‚ùå No compose file found!"
            exit 1
          fi
          
          docker stack deploy \
            --compose-file "$COMPOSE_FILE" \
            --with-registry-auth \
            $PROJECT_NAME
          
          echo "‚úÖ Stack deployed successfully!"
          
          # Quick service status (no waiting)
          echo "üìä Service status:"
          docker stack services $PROJECT_NAME --format 'table {{.Name}}\t{{.Replicas}}\t{{.Image}}' | head -10
          
          echo "üéâ Deployment completed in fast mode!"
          DEPLOY_EOF
          
          chmod +x deploy.sh

      - name: üìã Pre-deployment checks
        run: |
          echo "üîç Deployment Summary:"
          echo "Environment: ${{ steps.vars.outputs.ENVIRONMENT }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.IMAGE_TAG }}"
          echo "Project: ${{ vars.PROJECT_NAME }}"
          echo "Domain: ${{ vars.DOMAIN }}"
          echo "Server: ${{ secrets.DEPLOY_HOST }}"

      - name: üì§ Deploy to server
        timeout-minutes: 10
        run: |
          echo "üîó Testing SSH connection..."
          ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} "echo 'SSH connection successful'"
          
          echo "üìÅ Setting up deployment directory..."
          ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "mkdir -p ~/deployments/${{ vars.PROJECT_NAME }}"
          
          echo "üì§ Copying files to server..."
          scp -i ~/.ssh/id_rsa -o ConnectTimeout=10 docker-compose.yml \
            ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:~/deployments/${{ vars.PROJECT_NAME }}/docker-compose.yml
          
          scp -i ~/.ssh/id_rsa -o ConnectTimeout=10 .env.deploy \
            ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:~/deployments/${{ vars.PROJECT_NAME }}/.env
          
          scp -i ~/.ssh/id_rsa -o ConnectTimeout=10 deploy.sh \
            ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }}:~/deployments/${{ vars.PROJECT_NAME }}/deploy.sh
          
          echo "üöÄ Starting deployment..."
          ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 -o ServerAliveInterval=30 ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "cd ~/deployments/${{ vars.PROJECT_NAME }} && \
             export PROJECT_NAME=${{ vars.PROJECT_NAME }} && \
             export IMAGE_TAG=${{ steps.vars.outputs.IMAGE_TAG }} && \
             export DOMAIN=${{ vars.DOMAIN }} && \
             ./deploy.sh"

      - name: üß™ Health check
        timeout-minutes: 3
        run: |
          echo "üîç Running quick health checks..."
          
          # Quick service status check
          ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
            "docker stack services ${{ vars.PROJECT_NAME }} --format 'table {{.Name}}\t{{.Replicas}}\t{{.Image}}' | head -5"
          
          echo "‚úÖ Health check completed - services are being deployed"
          echo "‚ÑπÔ∏è Note: Full service startup may take a few minutes after deployment"

      - name: üìä Deployment summary
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ steps.vars.outputs.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.IMAGE_TAG }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Project:** ${{ vars.PROJECT_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "**Domain:** ${{ vars.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Time:** ${{ steps.vars.outputs.DEPLOYMENT_TIME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Access" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** https://${{ vars.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check:** https://${{ vars.DOMAIN }}/health" >> $GITHUB_STEP_SUMMARY

      - name: üßπ Cleanup
        timeout-minutes: 2
        if: always()
        run: |
          # Clean up old images on remote server (before removing SSH key)
          if [ -f ~/.ssh/id_rsa ]; then
            echo "üßπ Cleaning up old Docker images..."
            ssh -i ~/.ssh/id_rsa -o ConnectTimeout=10 ${{ secrets.DEPLOY_USER }}@${{ secrets.DEPLOY_HOST }} \
              "docker image prune -f --filter 'dangling=true' || echo 'Cleanup failed - continuing'" 2>/dev/null || true
          fi
          
          # Remove sensitive files
          echo "üîí Cleaning up sensitive files..."
          rm -f .env.deploy
          rm -f deploy.sh
          rm -f ~/.ssh/id_rsa
          rm -f ~/.ssh/config
          
          echo "‚úÖ Cleanup completed"

  notify:
    needs: deploy
    runs-on: ubuntu-latest
    if: always()
    env:
      PROJECT_NAME: fishboard
      DOMAIN: fishboard.abstraktagencia.com
    
    steps:
      - name: üì¢ Notify deployment status
        uses: actions/github-script@v7
        if: github.event_name == 'release'
        with:
          script: |
            const status = '${{ needs.deploy.result }}';
            const tag = '${{ github.ref_name }}';
            const domain = '${{ vars.DOMAIN }}';
            const projectName = '${{ vars.PROJECT_NAME }}';
            
            const emoji = status === 'success' ? '‚úÖ' : '‚ùå';
            const statusText = status === 'success' ? 'Successfully Deployed' : 'Deployment Failed';
            
            const comment = \`## \${emoji} Docker Swarm Deployment \${statusText}
            
            **Release:** \${tag}
            **Stack:** \`\${projectName}\`
            **Status:** \${statusText}
            
            \${status === 'success' ? 
              \`### üîó Access Links
              - **Application:** https://\${domain}
              - **Health Check:** https://\${domain}/health
              
              The application has been deployed to Docker Swarm and is ready to use!` :
              \`### ‚ùå Deployment Issues
              Please check the workflow logs for details about the deployment failure.
              You may need to investigate the Docker Swarm cluster or configuration.\`
            }\`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.release.id,
              body: comment
            });